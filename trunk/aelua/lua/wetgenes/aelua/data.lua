local Json=require("Json")local pairs=pairslocal core=require("wetgenes.aelua.data.core")module("wetgenes.aelua.data")function keyinfo(keystr)	return core.keyinfo(keystr)endfunction keystr(kind,id,parent)	return core.keystr(kind,id,parent)endfunction del(ent)	return core.del(nil,ent)endfunction put(ent)	return core.put(nil,ent)endfunction get(ent)	return core.get(nil,ent)endfunction query(q)	return core.query(nil,q)end--------------------------------------------------------------------------------- Begin a transaction, use the functions inside the returned table-- to perform actions within this transaction---- the basic code flow is that you should begin one transaction per entity(parent)-- and then rollback all when one fails. the first del/put/get locks the entity-- we are dealing with in this transaction---- after the t.fail flag gets set on a put/del then everything apart from rollback just returns nil-- and commit is turned into an auto rollback---- so this is OK transaction code, just remember that puts may not auto generate a key-- and there may be other reasons for fails---- for _=1,10 do -- try a few times--     t=begin()--     t.get(e)--     t.put(e)--     t.commit()--     if not t.fail then break end -- success-- end-------------------------------------------------------------------------------function begin()	local t={}	t.core=core.begin()		t.fail=false -- this will be set to true when a transaction action fails and should rollback and retry		t.del=function(ent)	if t.fail then return nil end return core.del(t,ent) end -- these are the same as the global ones	t.put=function(ent)	if t.fail then return nil end return core.put(t,ent) end	t.get=function(ent)	if t.fail then return nil end return core.get(t,ent) end	t.query=function(q)	if t.fail then return nil end return core.query(t,q) end		t.rollback=function() return core.rollback(t.core) end		t.commit  =function()	if t.fail then return core.rollback(t.core) end  return core.commit(  t.core) end		return tend--------------------------------------------------------------------------------- build cache which is a mixture of decoded json vars (this may contain sub tables)-- overiden by database props which do not contain tables but are midly searchable-- props.json should contain this json data string on input-- cache will be a filled in table to be used instead of props---- Not sure if this is more compact than just creating many real key/value pairs-- but it feels like a better way to organize. :)---- At least it is a bit more implicit about what can and cannot be searched for.-------------------------------------------------------------------------------function build_cache(v)	if v.props.json then -- expand the json data			v.cache=Json.Decode(v.props.json)			else			v.cache={}		end	for ii,vv in pairs(v.props) do -- override cache by props			v.cache[ii]=vv	end		return vend--------------------------------------------------------------------------------- a simplistic reverse of build cache-- any props of the same name will get updated from this cache-- rather than encoded into props.json-------------------------------------------------------------------------------function build_props(v)	local t={}		for i,v in pairs(v.cache) do		if v.props[i] then			v.props[i]=v.cache[i] -- if it exists as a prop then the prop is updated		else			t[i]=v.cache[i] -- else it just goes in the prop		end	end	v.props.json=Json.Encode(t)		return vend