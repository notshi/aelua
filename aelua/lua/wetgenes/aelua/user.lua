local Json=require("Json")local dat=require("wetgenes.aelua.data")local cache=require("wetgenes.aelua.cache")local core=require("wetgenes.aelua.user.core")local os=oslocal string=stringlocal math=mathlocal tostring=tostringlocal wet_string=require("wetgenes.string")local str_split=wet_string.str_splitlocal serialize=wet_string.serializemodule("wetgenes.aelua.user")function login_url(a)	return core.login_url(a)endfunction logout_url(a)	return core.logout_url(a)end--------------------------------------------------------------------------------- an email (always all lowercase) is a user@domain string identifier-- sometimes this may not be a real email but just indicate a unique account-- for instance 1234567@id.facebook.com -- email is just used as a convienient term for such strings-- it harkens to the day when facebook will finally forfill the prophecy-- of every application evolving to the point where it can send and recieve email-- I notice that myspace already has...---------------------------------------------------------------------------------------------------------------------------------------------------------------- get userdata, this is a database sored chunk of data associated with the current logged in user-- this data is also memcache mapped :TODO---- it is stored in user.data---- this function will forcebly fill in that value from the database---- after getting this data the user.name and user.email and even user.admin may get updated-- the currently logged in user could belong to another master user whoes emails and name-- will override the settings.-------------------------------------------------------------------------------function get_user_data()	if not user then return end -- no user to work with	local ent={key={kind="user.data",id=user.email}} -- email is key value for this empty entity		if not dat.get(ent) then put_user_data() return end -- create a new user on empty get, this should be safeish		dat.build_cache(ent) -- most data is kept in json		got_user_data(ent)endfunction got_user_data(ent)-- overide basic details	user.email=ent.cache.email or user.email	user.name=ent.cache.name or user.name		user.data=ent.cacheend--------------------------------------------------------------------------------- set userdata, this is a database stored chunk of data associated with the current logged in user-- this data is also memcache mapped :TODO---- it is stored in user.data---- this function will take the data from user.data and write it to the database-- use when a user has adjusted their options and the data sould be saved-------------------------------------------------------------------------------function put_user_data()	if not user then return end -- no user to work with	if not user.data then -- no data to work with, so make a default one		user.data={}		user.data.created=os.time()		user.data.email=user.email		user.data.name=user.name	end	local ent={key={kind="user.data",id=user.email},props={}} -- email is the key value for this empty entity	-- time stamps	ent.props.created=user.data.created	ent.props.updated=os.time()-- this is the email of the user account that owns this user account (probably points to self)	ent.props.email=user.data.email	-- and finaly the json block	ent.props.json=Json.Encode(user.data)		dat.put(ent)	end--------------------------------------------------------------------------------- get a user ent by email within the given transaction t-- you may edit the cache values after this get in preperation for a put-- -----------------------------------------------------------------------------function get_user_ent(t,email)	if t.fail then return nil end		local ent={key={kind="user.data",id=email}} -- email is key value for this empty entity		t.get(ent)	if not t.fail then		dat.build_cache(ent) -- most data is kept in json	end		return entend--------------------------------------------------------------------------------- convert the cache values to props then-- put a previously got user ent within the given transaction t---- after a succesful commit do a got_user_data(ent) to update the current user-- -----------------------------------------------------------------------------function put_user_ent(t,ent)	if t.fail then return nil end		dat.build_props(ent) -- most data is kept in json	return t.put(ent)end--------------------------------------------------------------------------------- associates a future action with the active user, returns a key valid for 5 minutes-- -----------------------------------------------------------------------------function put_act(dat)	if not user or not dat then return nil end	local id=tostring(math.random(10000,99999)) -- need a random number but "random" isnt a big issue	local key="act:"..user.email..":"..idlocal str=Json.Encode(dat)	cache.put(key,str,60*5)		return idend--------------------------------------------------------------------------------- retrives an action for this active user or nil if not a valid key-------------------------------------------------------------------------------function get_act(id)	if not user or not id then return nil end	local key="act:"..user.email..":"..idlocal str=cache.get(key)	if not str then return nil end -- notfound		cache.del(key) -- one use only		return Json.Decode(str)end--------------------------------------------------------------------------------- mirror the user data out from within the core---- this happens at load time...-------------------------------------------------------------------------------if core.user then	user={}		user.email=core.user.email	user.name=core.user.name	user.admin=core.user.admin	if not user.name or user.name=="" or user.name==user.email then			user.name=str_split("@",user.email)[1]				string.sub(user.name,1,32)		end	user.email=string.lower(user.email) -- make sure the email is all lowercase	-- get overides		get_user_data()end