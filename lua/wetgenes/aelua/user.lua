local Json=require("Json")local sys=require("wetgenes.aelua.sys")local dat=require("wetgenes.aelua.data")local core=require("wetgenes.aelua.user.core")local string=stringlocal wet_string=require("wetgenes.string")local str_split=wet_string.str_splitlocal serialize=wet_string.serializemodule("wetgenes.aelua.user")function login_url(a)	return core.login_url(a)endfunction logout_url(a)	return core.logout_url(a)end--------------------------------------------------------------------------------- an email (always all lowercase) is a user@domain string identifier-- sometimes this may not be a real email but just indicate a unique account-- for instance 1234567@facebook.com -- email is just used as a convienient term for such strings-- it harkens to the day when facebook will finally forfill the prophecy-- of every application evolving to the point where it can send and recieve email---------------------------------------------------------------------------------------------------------------------------------------------------------------- get userdata, this is a database sored chunk of data associated with the current logged in user-- this data is also memcache mapped :TODO---- it is stored in user.data---- this function will forcebly fill in that value from the database---- after getting this data the user.name and user.email and even user.admin may get updated-- he currently logged in user could belong to another master user whoes emails and name-- will override the settings.-------------------------------------------------------------------------------function get_user_data()	if not user then return end -- no user to work with	local ent={key={kind="user.data",id=user.email}} -- email is key value for this empty entity		dat.get(ent)		if not ent.props then put_user_data() return end -- create a new user		dat.build_cache(ent) -- most data is kept in json	-- overide basic details	user.email=ent.cache.email or user.email	user.name=ent.cache.name or user.name		user.data=ent.cacheend--------------------------------------------------------------------------------- set userdata, this is a database sored chunk of data associated with the current logged in user-- this data is also memcache mapped :TODO---- it is stored in user.data---- this function will take the data from user.data and write it to the database-- use when a user has adjusted their options and the data sould be saved-------------------------------------------------------------------------------function put_user_data()	if not user then return end -- no user to work with	if not user.data then -- no data to work with, so make a default one		user.data={}		user.data.created=sys.time()		user.data.email=user.email		user.data.name=user.name	end	local ent={key={kind="user.data",id=user.email},props={}} -- email is the key value for this empty entity	-- time stamps	ent.props.created=user.data.created	ent.props.updated=sys.time()-- this is the email of the user account that owns this user account (probably points to self)	ent.props.email=user.data.email	-- and finaly the json block	ent.props.json=Json.Encode(user.data)		dat.put(ent)	end--------------------------------------------------------------------------------- mirror the user data out from within the core---- this happens at load time...-------------------------------------------------------------------------------if core.user then	user={}		user.email=core.user.email	user.name=core.user.name	user.admin=core.user.admin	if not user.name or user.name=="" or user.name==user.email then			user.name=str_split("@",user.email)[1]				string.sub(user.name,1,32)		end	user.email=string.lower(user.email) -- make sure the email is all lowercase	-- get overides		get_user_data()end